"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.montgomery = void 0;
/**
 * Montgomery curve methods. It's not really whole montgomery curve,
 * just bunch of very specific methods for X25519 / X448 from
 * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var modular_js_1 = require("./modular.js");
var utils_1 = require("./utils.js");
var _0n = BigInt(0);
var _1n = BigInt(1);
function validateOpts(curve) {
    (0, utils_1.validateObject)(curve, {
        a: 'bigint',
    }, {
        montgomeryBits: 'isSafeInteger',
        nByteLength: 'isSafeInteger',
        adjustScalarBytes: 'function',
        domain: 'function',
        powPminus2: 'function',
        Gu: 'bigint',
    });
    // Set defaults
    return Object.freeze(__assign({}, curve));
}
// Uses only one coordinate instead of two
function montgomery(curveDef) {
    var CURVE = validateOpts(curveDef);
    var P = CURVE.P;
    var modP = function (n) { return (0, modular_js_1.mod)(n, P); };
    var montgomeryBits = CURVE.montgomeryBits;
    var montgomeryBytes = Math.ceil(montgomeryBits / 8);
    var fieldLen = CURVE.nByteLength;
    var adjustScalarBytes = CURVE.adjustScalarBytes || (function (bytes) { return bytes; });
    var powPminus2 = CURVE.powPminus2 || (function (x) { return (0, modular_js_1.pow)(x, P - BigInt(2), P); });
    // cswap from RFC7748. But it is not from RFC7748!
    /*
      cswap(swap, x_2, x_3):
           dummy = mask(swap) AND (x_2 XOR x_3)
           x_2 = x_2 XOR dummy
           x_3 = x_3 XOR dummy
           Return (x_2, x_3)
    Where mask(swap) is the all-1 or all-0 word of the same length as x_2
     and x_3, computed, e.g., as mask(swap) = 0 - swap.
    */
    function cswap(swap, x_2, x_3) {
        var dummy = modP(swap * (x_2 - x_3));
        x_2 = modP(x_2 - dummy);
        x_3 = modP(x_3 + dummy);
        return [x_2, x_3];
    }
    // x25519 from 4
    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519
    var a24 = (CURVE.a - BigInt(2)) / BigInt(4);
    /**
     *
     * @param pointU u coordinate (x) on Montgomery Curve 25519
     * @param scalar by which the point would be multiplied
     * @returns new Point on Montgomery curve
     */
    function montgomeryLadder(u, scalar) {
        (0, utils_1.aInRange)('u', u, _0n, P);
        (0, utils_1.aInRange)('scalar', scalar, _0n, P);
        // Section 5: Implementations MUST accept non-canonical values and process them as
        // if they had been reduced modulo the field prime.
        var k = scalar;
        var x_1 = u;
        var x_2 = _1n;
        var z_2 = _0n;
        var x_3 = u;
        var z_3 = _1n;
        var swap = _0n;
        var sw;
        for (var t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
            var k_t = (k >> t) & _1n;
            swap ^= k_t;
            sw = cswap(swap, x_2, x_3);
            x_2 = sw[0];
            x_3 = sw[1];
            sw = cswap(swap, z_2, z_3);
            z_2 = sw[0];
            z_3 = sw[1];
            swap = k_t;
            var A = x_2 + z_2;
            var AA = modP(A * A);
            var B = x_2 - z_2;
            var BB = modP(B * B);
            var E = AA - BB;
            var C = x_3 + z_3;
            var D = x_3 - z_3;
            var DA = modP(D * A);
            var CB = modP(C * B);
            var dacb = DA + CB;
            var da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
        }
        // (x_2, x_3) = cswap(swap, x_2, x_3)
        sw = cswap(swap, x_2, x_3);
        x_2 = sw[0];
        x_3 = sw[1];
        // (z_2, z_3) = cswap(swap, z_2, z_3)
        sw = cswap(swap, z_2, z_3);
        z_2 = sw[0];
        z_3 = sw[1];
        // z_2^(p - 2)
        var z2 = powPminus2(z_2);
        // Return x_2 * (z_2^(p - 2))
        return modP(x_2 * z2);
    }
    function encodeUCoordinate(u) {
        return (0, utils_1.numberToBytesLE)(modP(u), montgomeryBytes);
    }
    function decodeUCoordinate(uEnc) {
        // Section 5: When receiving such an array, implementations of X25519
        // MUST mask the most significant bit in the final byte.
        var u = (0, utils_1.ensureBytes)('u coordinate', uEnc, montgomeryBytes);
        if (fieldLen === 32)
            u[31] &= 127; // 0b0111_1111
        return (0, utils_1.bytesToNumberLE)(u);
    }
    function decodeScalar(n) {
        var bytes = (0, utils_1.ensureBytes)('scalar', n);
        var len = bytes.length;
        if (len !== montgomeryBytes && len !== fieldLen) {
            var valid = '' + montgomeryBytes + ' or ' + fieldLen;
            throw new Error('invalid scalar, expected ' + valid + ' bytes, got ' + len);
        }
        return (0, utils_1.bytesToNumberLE)(adjustScalarBytes(bytes));
    }
    function scalarMult(scalar, u) {
        var pointU = decodeUCoordinate(u);
        var _scalar = decodeScalar(scalar);
        var pu = montgomeryLadder(pointU, _scalar);
        // The result was not contributory
        // https://cr.yp.to/ecdh.html#validate
        if (pu === _0n)
            throw new Error('invalid private or public key received');
        return encodeUCoordinate(pu);
    }
    // Computes public key from private. By doing scalar multiplication of base point.
    var GuBytes = encodeUCoordinate(CURVE.Gu);
    function scalarMultBase(scalar) {
        return scalarMult(scalar, GuBytes);
    }
    return {
        scalarMult: scalarMult,
        scalarMultBase: scalarMultBase,
        getSharedSecret: function (privateKey, publicKey) { return scalarMult(privateKey, publicKey); },
        getPublicKey: function (privateKey) { return scalarMultBase(privateKey); },
        utils: { randomPrivateKey: function () { return CURVE.randomBytes(CURVE.nByteLength); } },
        GuBytes: GuBytes,
        encodeUCoordinate: encodeUCoordinate
    };
}
exports.montgomery = montgomery;

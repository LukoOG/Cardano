export declare class FieldElem51 {
    readonly bytes: BigUint64Array;
    constructor(bytes: BigUint64Array);
    static zero(): FieldElem51;
    static one(): FieldElem51;
    static minus_one(): FieldElem51;
    static get EDWARDS_D(): FieldElem51;
    static get EDWARDS_D2(): FieldElem51;
    static fromBytes(bytes: Uint8Array): FieldElem51;
    static elligator_encode(r_0: FieldElem51): MontgomeryPoint;
    static elligator_encode_var_time(r_0: FieldElem51): MontgomeryPoint;
    static conditional_select(a: FieldElem51, b: FieldElem51, choice: boolean): FieldElem51;
    static get MONTGOMERY_A_NEG(): FieldElem51;
    static get MONTGOMERY_A(): FieldElem51;
    pow2k(k: number): FieldElem51;
    square2(): FieldElem51;
    add(_rhs: FieldElem51): FieldElem51;
    static reduce(limbs: BigUint64Array): FieldElem51;
    sub(_rhs: FieldElem51): FieldElem51;
    mul(_rhs: FieldElem51): FieldElem51;
    invert(): FieldElem51;
    pow22501(): [FieldElem51, FieldElem51];
    square(): FieldElem51;
    static sqrt_ratio_i(u: FieldElem51, v: FieldElem51): [boolean, FieldElem51];
    is_negative(): boolean;
    conditional_negate(choice: boolean): void;
    conditional_assign(other: FieldElem51, choice: boolean): void;
    clone(): FieldElem51;
    neg(): FieldElem51;
    negate(): FieldElem51;
    ct_eq(other: FieldElem51): boolean;
    static get SQRT_M1(): FieldElem51;
    pow_p58(): FieldElem51;
    toBytes(): Uint8Array & {
        length: 32;
    };
}
export declare class MontgomeryPoint {
    readonly bytes: Uint8Array;
    constructor(bytes: Uint8Array);
    to_edwards(sign_bit: 0 | 1): EdwardsPoint | undefined;
}
export declare class EdwardsPoint {
    readonly X: FieldElem51;
    readonly Y: FieldElem51;
    readonly Z: FieldElem51;
    readonly T: FieldElem51;
    constructor(X: FieldElem51, Y: FieldElem51, Z: FieldElem51, T: FieldElem51);
    mulByPow2(k: number): EdwardsPoint;
    equals(other: EdwardsPoint): boolean;
    static get DOUBLE_BASE_COMPRESSED(): Uint8Array;
    static get BASEPOINT_ED25519_COMPRESSED(): Uint8Array;
    static get BASEPOINT_ED25519(): EdwardsPoint;
    is_valid(): boolean;
    static vartime_multiscalar_mul(scalars: Uint8Array[], points: EdwardsPoint[]): EdwardsPoint;
    double(): EdwardsPoint;
    static vartime_double_scalar_mul_basepoint(neg_challenge: Uint8Array, pk: EdwardsPoint, response: Uint8Array): EdwardsPoint;
    ct_eq(other: EdwardsPoint): boolean;
    static decompress(compressed: Uint8Array): EdwardsPoint | undefined;
    static uncompress(compressed: Uint8Array): EdwardsPoint | undefined;
    is_small_order(): boolean;
    is_identity(): boolean;
    clone(): EdwardsPoint;
    static get IDENTITY(): EdwardsPoint;
    add(other: EdwardsPoint): EdwardsPoint;
    addProjectiveNiels(other: ProjectiveNielsPoint): CompletedPoint;
    subProjectiveNiels(other: ProjectiveNielsPoint): CompletedPoint;
    addAffineNielsPoint(other: AffineNielsPoint): CompletedPoint;
    subAffineNielsPoint(other: AffineNielsPoint): CompletedPoint;
    toProjectiveNiels(): ProjectiveNielsPoint;
    mul_by_cofactor(): EdwardsPoint;
    compress(): Uint8Array & {
        length: 32;
    };
    compressed_is_negative(): boolean;
    mul_by_pow_2(k: number): EdwardsPoint;
    toProjective(): ProjectivePoint;
    scalarMul(scalar: Uint8Array): EdwardsPoint;
}
declare class AffineNielsPoint {
    readonly y_plus_x: FieldElem51;
    readonly y_minus_x: FieldElem51;
    readonly xy2d: FieldElem51;
    constructor(y_plus_x: FieldElem51, y_minus_x: FieldElem51, xy2d: FieldElem51);
}
export declare const ED25519_BASEPOINT_POINT: EdwardsPoint;
export declare class ProjectiveNielsPoint {
    readonly Y_plus_X: FieldElem51;
    readonly Y_minus_X: FieldElem51;
    readonly Z: FieldElem51;
    readonly T2d: FieldElem51;
    constructor(Y_plus_X: FieldElem51, Y_minus_X: FieldElem51, Z: FieldElem51, T2d: FieldElem51);
    clone(): ProjectiveNielsPoint;
    /** not really, but useful to debug */
    compress(): Uint8Array & {
        length: 32;
    };
    compressed_is_negative(): boolean;
    static identity(): ProjectiveNielsPoint;
    /**
     * # WARNING
     *
     * **I FOUND NO IMPLEMENTATION** (Thanks generics)
     *
     * I am ASSUMING this is what is meant to happen
     *
     */
    conditional_negate(choice: boolean): void;
    /**
     *
     * I HAD TO FUCKING REVERSE ENGENEER THIS SHIT
     *
     * WHO THE FUCK TOUGHT MACROS WERE A GOOD IDEA IN RUST?
     */
    neg(): ProjectiveNielsPoint;
    conditional_assign(other: ProjectiveNielsPoint, choice: boolean): void;
    static tableFromEdwardPoint(point: EdwardsPoint): LookupTableProjectiveNielsPoint;
}
export declare class LookupTableProjectiveNielsPoint {
    readonly points: ProjectiveNielsPoint[];
    constructor(points: ProjectiveNielsPoint[]);
    static readonly SIZE = 8;
    static readonly SIZE_NEG = -8;
    static readonly SIZE_RANGE: number[];
    static readonly SIZE_RANGE_MIN = 1;
    static readonly SIZE_RANGE_MAX = 8;
    static readonly CONVERSION_RANGE: number[];
    static readonly CONVERSION_RANGE_MAX = 7;
    select(pos: number): ProjectiveNielsPoint;
}
export declare function decompressCompressedEdwardsY(bytes: Uint8Array): EdwardsPoint | undefined;
export declare class CompletedPoint {
    readonly X: FieldElem51;
    readonly Y: FieldElem51;
    readonly Z: FieldElem51;
    readonly T: FieldElem51;
    constructor(X: FieldElem51, Y: FieldElem51, Z: FieldElem51, T: FieldElem51);
    clone(): CompletedPoint;
    toProjective(): ProjectivePoint;
    toExtended(): EdwardsPoint;
}
export declare class ProjectivePoint {
    readonly X: FieldElem51;
    readonly Y: FieldElem51;
    readonly Z: FieldElem51;
    constructor(X: FieldElem51, Y: FieldElem51, Z: FieldElem51);
    is_valid(): boolean;
    clone(): ProjectivePoint;
    toExtended(): EdwardsPoint;
    static get IDENTITY(): ProjectivePoint;
    double(): CompletedPoint;
}
export declare function scalar_from_u64(n: bigint | number): Uint8Array;
export declare function scalar_from_bytes_mod_order_wide(input: Uint8Array): Uint8Array;
export declare function mul_scalars(a: Uint8Array, b: Uint8Array): Uint8Array;
export declare function add_scalars(a: Uint8Array, b: Uint8Array): Uint8Array;
declare function unpacked_scalar_from_bytes(input: Uint8Array): BigUint64Array;
export declare const unpack_scalar: typeof unpacked_scalar_from_bytes;
export declare function unpacked_scalar_from_bytes_wide(input: Uint8Array): BigUint64Array;
export declare function pack_unpacked_scalar(input: BigUint64Array): Uint8Array;
export declare function negate_scalar(scalar: Uint8Array): Uint8Array;
export {};

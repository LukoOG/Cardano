import { EdwardsPoint } from "./curves.js";
export interface IVrfProof03 {
    gamma: EdwardsPoint;
    challenge: Uint8Array;
    response: Uint8Array;
}
export declare function extend_secret_key(secret_key: Uint8Array): [scalar: Uint8Array, extension: Uint8Array];
export declare function adjust_scalar_bits(bytes: Uint8Array): void;
export declare function vrf_ed25519_sha512_ell2_generate_proof(secret_key: Uint8Array, public_key: Uint8Array, alpha_string: Uint8Array): IVrfProof03;
export declare function vrf_ed25519_sha512_ell2_verify_proof(public_key: Uint8Array, alpha_string: Uint8Array, proof: IVrfProof03): boolean;
export declare function proof_to_hash(proof: IVrfProof03): Uint8Array & {
    length: 64;
};
export declare function edwards_hash_from_bytes(bytes: Uint8Array): EdwardsPoint;
export declare function vrf_ed25519_sha512_ell2_hash_to_curve(public_key: Uint8Array, alpha_string: Uint8Array): EdwardsPoint;
export declare function scalar_hash_from_bytes(input: Uint8Array): Uint8Array;
export declare function vrf_ed25519_sha512_ell2_nonce_generation(secret_extension: Uint8Array, compressed_h: Uint8Array): Uint8Array;
export declare function vrf_ed25519_sha512_ell2_compute_challenge(compressed_h: Uint8Array, compressed_gamma: Uint8Array, compressed_announcement_1: Uint8Array, compressed_announcement_2: Uint8Array): Uint8Array;
export declare function scalar_from_bits_inplace(bytes: Uint8Array): void;
/**
 * https://datatracker.ietf.org/doc/html/rfc9381#section-5.1
 *
 * test cases:
 * https://datatracker.ietf.org/doc/html/rfc9381#name-ecvrf-edwards25519-sha512-e
 * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-03#appendix-A.4
 *
 * /// Generate a new VRF proof following the 03 standard. It proceeds as follows:
 * /// - Extend the secret key, into a `secret_scalar` and the `secret_extension`
 * /// - Evaluate `hash_to_curve` over PK || alpha_string to get `H`
 * /// - Compute `Gamma = secret_scalar *  H`
 * /// - Generate a proof of discrete logarithm equality between `PK` and `Gamma` with
 * ///   bases `generator` and `H` respectively.
 *
 * /
export function vrf_ed25519_sha512_ell2_prove(sk: Uint8Array, alpha: Uint8Array): IVrfProof03
{
    /// - Extend the secret key, into a `secret_scalar` and the `secret_extension`
    const [ scalar, extension ] = getExtendEd25519PrivateKeyComponents_sync( sk );
    // 1. Use SK to derive the VRF secret scalar x and the VRF public key Y = x*B
    /// - Evaluate `hash_to_curve` over PK || alpha_string to get `H`
    const pk = new Uint8Array( deriveEd25519PublicKey_sync( sk ) );
    const H = vrf_ed25519_sha512_ell2_hash_to_curve( pk, alpha );
    
    const H_point = pointFromBytes( H );
    const gamma = scalarMul( H_point, scalar );
    const compressed_gamma = bigpointToUint8Array( gamma );
    const k = vrf_ed25519_sha512_ell2_nonce_generation( extension, H );
    const announcement_1 = bigpointToUint8Array( scalarMultBase( k ) );
    const announcement_2 = bigpointToUint8Array( scalarMul( H_point, k ) );
    const challange = scalarFromBytes(
        vrf_ed25519_sha512_ell2_challenge_generation( H, compressed_gamma, announcement_1, announcement_2 )
    );
    const response = k + challange * scalar;
    return {
        gamma,
        challange,
        response
    };
}
//*/ 

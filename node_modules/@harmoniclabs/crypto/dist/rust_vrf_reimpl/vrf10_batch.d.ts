import { EdwardsPoint } from "./curves.js";
export interface IVrfBatchProof10 {
    gamma: EdwardsPoint;
    u_point: EdwardsPoint;
    v_point: EdwardsPoint;
    response: Uint8Array;
}
export declare function vrf10_batch_ed25519_sha512_ell2_proof_to_hash(proof: IVrfBatchProof10): Uint8Array & {
    length: 64;
};
export declare function vrf10_batch_ed25519_sha512_ell2_generate_proof(secret_key: Uint8Array, public_key: Uint8Array, alpha_string: Uint8Array): IVrfBatchProof10;
export declare function vrf10_batch_ed25519_sha512_ell2_verify_proof(public_key: Uint8Array, alpha_string: Uint8Array, proof: IVrfBatchProof10): boolean;
/**
 * https://datatracker.ietf.org/doc/html/rfc9381#section-5.1
 *
 * test cases:
 * https://datatracker.ietf.org/doc/html/rfc9381#name-ecvrf-edwards25519-sha512-e
 * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-10#appendix-A.4
 *
 * /// Generate a new VRF proof following the 10 standard. It proceeds as follows:
 * /// - Extend the secret key, into a `secret_scalar` and the `secret_extension`
 * /// - Evaluate `hash_to_curve` over PK || alpha_string to get `H`
 * /// - Compute `Gamma = secret_scalar *  H`
 * /// - Generate a proof of discrete logarithm equality between `PK` and `Gamma` with
 * ///   bases `generator` and `H` respectively.
 *
 * /
function vrf_ed25519_sha512_ell2_prove(sk: Uint8Array, alpha: Uint8Array): IVrfBatchProof10
{
    /// - Extend the secret key, into a `secret_scalar` and the `secret_extension`
    const [ scalar, extension ] = getExtendEd25519PrivateKeyComponents_sync( sk );
    // 1. Use SK to derive the VRF secret scalar x and the VRF public key Y = x*B
    /// - Evaluate `hash_to_curve` over PK || alpha_string to get `H`
    const pk = new Uint8Array( deriveEd25519PublicKey_sync( sk ) );
    const H = vrf_ed25519_sha512_ell2_hash_to_curve( pk, alpha );
    
    const H_point = pointFromBytes( H );
    const gamma = scalarMul( H_point, scalar );
    const compressed_gamma = bigpointToUint8Array( gamma );
    const k = vrf_ed25519_sha512_ell2_nonce_generation( extension, H );
    const announcement_1 = bigpointToUint8Array( scalarMultBase( k ) );
    const announcement_2 = bigpointToUint8Array( scalarMul( H_point, k ) );
    const challange = scalarFromBytes(
        vrf_ed25519_sha512_ell2_challenge_generation( H, compressed_gamma, announcement_1, announcement_2 )
    );
    const response = k + challange * scalar;
    return {
        gamma,
        challange,
        response
    };
}
//*/ 

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyEd25519Signature = exports.verifyEd25519Signature_sync = exports.getEd25519Signature = exports.getEd25519Signature_sync = exports.signExtendedEd25519 = exports.signExtendedEd25519_sync = exports.signEd25519 = exports.signEd25519_sync = exports.extendedToPublic = exports.deriveEd25519PublicKey = exports.deriveEd25519PublicKey_sync = exports.getExtendedEd25519PrivateKey = exports.getExtendedEd25519PrivateKey_sync = exports.getExtendEd25519PrivateKeyComponents_sync = exports.getExtendEd25519PrivateKeyComponentsAsBytes_sync = exports.scalarMultBase = exports.scalarToBytes = exports.scalarFromBytes = exports.pointFromBytes = exports.bigpointToUint8Array = exports.encodeInt = exports.scalarMul = exports.addPointsEdwards = exports.ed25519bigint = void 0;
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var sha2_512_1 = require("./sha2_512.js");
var types_1 = require("./types.js");
var positiveMod_1 = require("./utils/positiveMod.js");
var bigintToBuffer_1 = require("./utils/bigintToBuffer.js");
var hasGlobalWebCrypto_1 = require("./hasGlobalWebCrypto.js");
// "Ed25519" does not seem to have great support yet
var __hasNativeSupport = false && (hasGlobalWebCrypto_1.hasGlobalWebCrypto
    && typeof globalThis.crypto.subtle.importKey === "function"
    && typeof globalThis.crypto.subtle.sign === "function"
    && typeof globalThis.crypto.subtle.verify === "function");
var NATIVE_ALGO_NAME = "Ed25519";
var NATIVE_ALGO = Object.freeze({ name: NATIVE_ALGO_NAME });
var importKey = __hasNativeSupport ?
    globalThis.crypto.subtle.importKey.bind(globalThis.crypto.subtle) :
    function () { return Promise.resolve(new ArrayBuffer(0)); };
function getNativePrivateKey(bytes) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    // ensure 64 bytes
                    if (bytes.length === 32)
                        bytes = getExtendedEd25519PrivateKey_sync(bytes);
                    return [4 /*yield*/, importKey("raw", bytes, NATIVE_ALGO, false, ["sign", "deriveKey"])];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
function getNativePublicKey(bytes) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, importKey("raw", bytes, NATIVE_ALGO, false, ["verify"])];
        });
    });
}
function nativeEd25519Sign(privateKey, data) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, _b, _c, _d;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0: return [4 /*yield*/, ensureNativeSupport()];
                case 1:
                    if (!(_e.sent()))
                        return [2 /*return*/, getEd25519Signature_sync(privateKey, data)];
                    _a = Uint8Array.bind;
                    _c = (_b = globalThis.crypto.subtle).sign;
                    _d = [NATIVE_ALGO_NAME];
                    return [4 /*yield*/, getNativePrivateKey(privateKey)];
                case 2: return [4 /*yield*/, _c.apply(_b, _d.concat([_e.sent(), data]))];
                case 3: return [2 /*return*/, new (_a.apply(Uint8Array, [void 0, _e.sent()]))()];
            }
        });
    });
}
var ED25519_ORDER = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949');
function ed25519bigint(n) {
    return (0, positiveMod_1.positiveMod)(n, ED25519_ORDER);
}
exports.ed25519bigint = ed25519bigint;
function toArrayBuffer(bytes) {
    if (bytes instanceof ArrayBuffer)
        return bytes;
    var buffer = new ArrayBuffer(bytes.length);
    var view = new Uint8Array(buffer);
    view.set(bytes);
    return buffer;
}
function nativeEd25519Verify(publicKey, signature, data) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, _b, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0: return [4 /*yield*/, ensureNativeSupport()];
                case 1:
                    if (!(_d.sent()))
                        return [2 /*return*/, verifyEd25519Signature_sync(signature, data, publicKey)];
                    _b = (_a = globalThis.crypto.subtle).verify;
                    _c = [NATIVE_ALGO_NAME];
                    return [4 /*yield*/, getNativePublicKey(publicKey)];
                case 2: return [2 /*return*/, _b.apply(_a, _c.concat([_d.sent(), toArrayBuffer(signature),
                        toArrayBuffer(data)]))];
            }
        });
    });
}
function _test(privateKey, publicKey, data, uint8ArrayEq) {
    return __awaiter(this, void 0, void 0, function () {
        var privBytes, _a, pubBytes, _b, nativeSignResult, nativeVerifyResult, mySignResult, myVerifyResult, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _d.trys.push([0, 5, , 6]);
                    _a = Uint8Array.bind;
                    return [4 /*yield*/, globalThis.crypto.subtle.exportKey("raw", privateKey)];
                case 1:
                    privBytes = new (_a.apply(Uint8Array, [void 0, _d.sent()]))();
                    _b = Uint8Array.bind;
                    return [4 /*yield*/, globalThis.crypto.subtle.exportKey("raw", publicKey)];
                case 2:
                    pubBytes = new (_b.apply(Uint8Array, [void 0, _d.sent()]))();
                    return [4 /*yield*/, nativeEd25519Sign(privBytes, data)];
                case 3:
                    nativeSignResult = _d.sent();
                    return [4 /*yield*/, nativeEd25519Verify(pubBytes, nativeSignResult, data)];
                case 4:
                    nativeVerifyResult = _d.sent();
                    mySignResult = getEd25519Signature_sync(data, privBytes);
                    myVerifyResult = verifyEd25519Signature_sync(mySignResult, data, pubBytes);
                    __hasNativeSupport = (__hasNativeSupport &&
                        uint8ArrayEq(nativeSignResult, mySignResult) &&
                        nativeVerifyResult === myVerifyResult);
                    return [3 /*break*/, 6];
                case 5:
                    _c = _d.sent();
                    __hasNativeSupport = false;
                    return [3 /*break*/, 6];
                case 6: return [2 /*return*/];
            }
        });
    });
}
var _support_was_tested = false;
function _test_support() {
    return __awaiter(this, void 0, void 0, function () {
        var _keyPair /* { privateKey, publicKey } */, extendedPrivate, cryptoPrivate, repeatArr, eqU8Arr, bench, sum, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (_support_was_tested || !__hasNativeSupport)
                        return [2 /*return*/];
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 5, , 6]);
                    return [4 /*yield*/, globalThis.crypto.subtle.generateKey(NATIVE_ALGO, true, ["sign", "verify"])];
                case 2:
                    _keyPair = (_b.sent());
                    extendedPrivate = new Uint8Array(64);
                    globalThis.crypto.getRandomValues(extendedPrivate);
                    return [4 /*yield*/, getNativePrivateKey(extendedPrivate)];
                case 3:
                    cryptoPrivate = _b.sent();
                    repeatArr = function (arr, n) {
                        for (var i = 0; i < n; i++)
                            arr = arr.concat.apply(arr, __spreadArray([], __read(arr), false));
                        return arr;
                    };
                    eqU8Arr = function (a, b) {
                        if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array))
                            return false;
                        if (a.length !== b.length)
                            return false;
                        for (var i = 0; i < a.length; i++)
                            if (a[i] !== b[i])
                                return false;
                        return true;
                    };
                    return [4 /*yield*/, Promise.all(
                        // repeatArr(
                        //     [
                        //         new Uint8Array( 0 ),
                        //         new Uint8Array( 10 ),
                        //         new Uint8Array([ 0xde, 0xad, 0xbe, 0xef ]),
                        // 
                        //         new Uint8Array( repeatArr([0xaa], 20 ) ),
                        //         new Uint8Array( repeatArr([0xbb], 20 ) ),
                        //         new Uint8Array( repeatArr([0xcc], 20 ) ),
                        //         new Uint8Array( repeatArr([0xdd], 20 ) ),
                        //         new Uint8Array( repeatArr([0xee], 20 ) ),
                        //         new Uint8Array( repeatArr([0xff], 20 ) ),
                        // 
                        //         new Uint8Array( repeatArr([0xaa, 0xbb], 33 ) ),
                        //         new Uint8Array( repeatArr([0xbb, 0xcc], 33 ) ),
                        //         new Uint8Array( repeatArr([0xcc, 0xdd], 33 ) ),
                        //         new Uint8Array( repeatArr([0xdd, 0xee], 33 ) ),
                        //         new Uint8Array( repeatArr([0xee, 0xff], 33 ) ),
                        //         new Uint8Array( repeatArr([0xff, 0x00], 33 ) ),
                        // 
                        //         new Uint8Array( repeatArr([ 0xde, 0xad, 0xbe, 0xef ], 30 ) ),
                        //     ],
                        //     10
                        // )
                        // .map( data => _test( privateKey, publicKey, data, uint8ArrayEq ) )
                        [])];
                case 4:
                    bench = _b.sent();
                    if (!__hasNativeSupport)
                        return [2 /*return*/];
                    sum = bench.reduce(function (acc, _a) {
                        var _b = __read(_a, 2), native = _b[0], js = _b[1];
                        acc[0] += native;
                        acc[1] += js;
                        return acc;
                    }, [0, 0]);
                    __hasNativeSupport = __hasNativeSupport && sum[0] < sum[1];
                    return [3 /*break*/, 6];
                case 5:
                    _a = _b.sent();
                    __hasNativeSupport = false;
                    _support_was_tested = true;
                    return [3 /*break*/, 6];
                case 6:
                    _support_was_tested = true;
                    return [2 /*return*/];
            }
        });
    });
}
if (__hasNativeSupport) {
    _test_support();
}
else {
    _support_was_tested = true;
}
/**
 * There are cases where `globalThis.crypto.subtle` is fully defined
 * but the algorithm `Ed25519` is NOT SUPPORTED.
 *
 * unfortunately, there is NO WAY to check this syncronously.
 */
function ensureNativeSupport() {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!__hasNativeSupport)
                        return [2 /*return*/, false];
                    return [4 /*yield*/, _test_support()];
                case 1:
                    _a.sent();
                    return [2 /*return*/, __hasNativeSupport];
            }
        });
    });
}
var Q = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"); // ipowi(255) - 19
var Q38 = BigInt("7237005577332262213973186563042994240829374041602535252466099000494570602494"); // (Q + 3)/8
var CURVE_ORDER = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"); // ipow2(252) + 27742317777372353535851937790883648493;
var D = -BigInt("4513249062541557337682894930092624173785641285191125241628941591882900924598840740"); // -121665 * invert(121666);
var I = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"); // expMod(BigInt( 2 ), (Q - BigInt( 1 ))/4, Q);
var BASE = Object.freeze([
    BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960") // (4*invert(5)) % Q
]);
/**
 *
 * @param {bigint} b
 * @param {bigint} e
 * @param {bigint} m
 * @returns {bigint}
 */
function expMod(b, e, m) {
    if (e == BigInt(0)) {
        return BigInt(1);
    }
    else {
        var t = expMod(b, e / BigInt(2), m);
        t = (t * t) % m;
        if ((e % BigInt(2)) !== BigInt(0)) {
            t = (0, positiveMod_1.positiveMod)(t * b, m);
        }
        return t;
    }
}
function invert(n) {
    var a = (0, positiveMod_1.positiveMod)(n, Q);
    var b = Q;
    var x = BigInt(0);
    var y = BigInt(1);
    var u = BigInt(1);
    var v = BigInt(0);
    while (a !== BigInt(0)) {
        var q = b / a;
        var r = b % a;
        var m = x - u * q;
        var n_1 = y - v * q;
        b = a;
        a = r;
        x = u;
        y = v;
        u = m;
        v = n_1;
    }
    return (0, positiveMod_1.positiveMod)(x, Q);
}
/**
 * @param {bigint} y
 * @returns {bigint}
 */
function recoverX(y) {
    var yy = y * y;
    var xx = (yy - BigInt(1)) * invert(D * yy + BigInt(1));
    var x = expMod(xx, Q38, Q);
    if (((x * x - xx) % Q) !== BigInt(0)) {
        x = (x * I) % Q;
    }
    if ((x % BigInt(2)) !== BigInt(0)) {
        x = Q - x;
    }
    return x;
}
/**
 * Curve point 'addition'
 * Note: this is probably the bottleneck of this Ed25519 implementation
 */
function addPointsEdwards(a, b) {
    var x1 = a[0];
    var y1 = a[1];
    var x2 = b[0];
    var y2 = b[1];
    var dxxyy = D * x1 * x2 * y1 * y2;
    var x3 = (x1 * y2 + x2 * y1) * invert(BigInt(1) + dxxyy);
    var y3 = (y1 * y2 + x1 * x2) * invert(BigInt(1) - dxxyy);
    return [(0, positiveMod_1.positiveMod)(x3, Q), (0, positiveMod_1.positiveMod)(y3, Q)];
}
exports.addPointsEdwards = addPointsEdwards;
function scalarMul(point, n) {
    if (n === BigInt(0)) {
        return [BigInt(0), BigInt(1)];
    }
    else {
        var sum = scalarMul(point, n / BigInt(2));
        sum = addPointsEdwards(sum, sum);
        if ((n % BigInt(2)) !== BigInt(0)) {
            sum = addPointsEdwards(sum, point);
        }
        return sum;
    }
}
exports.scalarMul = scalarMul;
/**
 * Curve point 'multiplication'
 */
function encodeInt(y) {
    return (0, bigintToBuffer_1.bigintToBuffer)(y, 32).reverse();
}
exports.encodeInt = encodeInt;
function decodeInt(s) {
    return BigInt("0x" + (0, types_1.byteArrToHex)(s.reverse()));
}
function bigpointToByteArray(point) {
    var _a = __read(point, 2), x = _a[0], y = _a[1];
    var bytes = encodeInt(y);
    // last bit is determined by x
    bytes[31] = ((bytes[31] & 255) | (Number(x & BigInt(1)) * 128));
    return bytes;
}
function bigpointToUint8Array(point) {
    return new Uint8Array(bigpointToByteArray(point));
}
exports.bigpointToUint8Array = bigpointToUint8Array;
function getBit(bytes, i) {
    return ((bytes[Math.floor(i / 8)] >> i % 8) & 1);
}
function isOnCurve(point) {
    var x = point[0];
    var y = point[1];
    var xx = x * x;
    var yy = y * y;
    return (-xx + yy - BigInt(1) - D * xx * yy) % Q == BigInt(0);
}
function pointFromBytes(s) {
    if (!(s instanceof Uint8Array))
        s = forceUint8Array(s);
    // assert(s.length === 32, "point must have length of 32; point length:" + s.length);
    var bytes = s.slice(0, 32);
    bytes[31] = (bytes[31] & 127);
    var y = decodeInt(bytes);
    var x = recoverX(y);
    if (Number(x & BigInt(1)) !== getBit(s, 255)) {
        x = Q - x;
    }
    var point = [x, y];
    if (!isOnCurve(point))
        throw new Error("point isn't on curve");
    return point;
}
exports.pointFromBytes = pointFromBytes;
var ipow2_253 = BigInt("28948022309329048855892746252171976963317496166410141009864396001978282409984"); // ipow2(253)
function scalarFromBytes(h) {
    var bytes = h.slice(0, 32);
    bytes[0] = (bytes[0] & 248);
    bytes[31] = (bytes[31] & 63);
    return ipow2_253 + BigInt("0x" + (0, types_1.byteArrToHex)(bytes.reverse()));
}
exports.scalarFromBytes = scalarFromBytes;
function scalarToBytes(s) {
    s = (0, positiveMod_1.positiveMod)(s, CURVE_ORDER);
    var bytes = encodeInt(s);
    bytes.reverse();
    return bytes;
}
exports.scalarToBytes = scalarToBytes;
function ihash(m) {
    return decodeInt((0, sha2_512_1.sha2_512_sync)(m));
}
function forceUint8Array(stuff) {
    if (stuff instanceof Uint8Array)
        return stuff;
    if (stuff instanceof ArrayBuffer)
        return new Uint8Array(stuff);
    if (typeof stuff === "string")
        return (0, uint8array_utils_1.fromHex)(stuff);
    return new Uint8Array(stuff);
}
function scalarMultBase(scalar) {
    return scalarMul(BASE, scalar);
}
exports.scalarMultBase = scalarMultBase;
////////////////////////////////////////////////////////////////////////////////////////////////////////// 
//------------------------------------------------------------------------------------------------------// 
//------------------------------------------- key management -------------------------------------------// 
//------------------------------------------- and derivation -------------------------------------------// 
//------------------------------------------------------------------------------------------------------// 
////////////////////////////////////////////////////////////////////////////////////////////////////////// 
function getExtendEd25519PrivateKeyComponentsAsBytes_sync(privateKey) {
    var extended = (0, sha2_512_1.sha2_512_sync)(privateKey);
    return [extended.slice(0, 32), extended.slice(32, 64)];
}
exports.getExtendEd25519PrivateKeyComponentsAsBytes_sync = getExtendEd25519PrivateKeyComponentsAsBytes_sync;
function getExtendEd25519PrivateKeyComponents_sync(privateKey) {
    var _a = __read(getExtendEd25519PrivateKeyComponentsAsBytes_sync(privateKey), 2), a_bytes = _a[0], extension = _a[1];
    return [scalarFromBytes(a_bytes), extension];
}
exports.getExtendEd25519PrivateKeyComponents_sync = getExtendEd25519PrivateKeyComponents_sync;
function getExtendedEd25519PrivateKey_sync(privateKey) {
    privateKey = Uint8Array.prototype.slice.call(forceUint8Array(privateKey), 0, 32);
    var extended = (0, sha2_512_1.sha2_512_sync)(privateKey);
    extended.set(privateKey, 0);
    return extended;
}
exports.getExtendedEd25519PrivateKey_sync = getExtendedEd25519PrivateKey_sync;
function getExtendedEd25519PrivateKey(privateKey) {
    return __awaiter(this, void 0, void 0, function () {
        var extended;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    // here `__hasNativeSupport` instead of `await ensureNativeSupport()` is fine
                    // because we want to use `sha2_512`, wich implies different tests than the ones
                    // used in `ensureNativeSupport`; `__hasNativeSupport` at least tell us if there is a `crypto` global at all 
                    if (!__hasNativeSupport)
                        return [2 /*return*/, getExtendedEd25519PrivateKey_sync(privateKey)];
                    privateKey = Uint8Array.prototype.slice.call(forceUint8Array(privateKey), 0, 32);
                    return [4 /*yield*/, (0, sha2_512_1.sha2_512)(privateKey)];
                case 1:
                    extended = _a.sent();
                    extended.set(privateKey, 0);
                    return [2 /*return*/, extended];
            }
        });
    });
}
exports.getExtendedEd25519PrivateKey = getExtendedEd25519PrivateKey;
function deriveEd25519PublicKey_sync(privateKey) {
    var extended = (0, sha2_512_1.sha2_512_sync)(privateKey);
    var a = scalarFromBytes(extended);
    var A = scalarMul(BASE, a);
    return bigpointToByteArray(A);
}
exports.deriveEd25519PublicKey_sync = deriveEd25519PublicKey_sync;
function wrapped_deriveEd25519PublicKey_sync(privateKey) {
    return Promise.resolve(deriveEd25519PublicKey_sync(privateKey));
}
function deriveEd25519PublicKey_async(privateKey) {
    return __awaiter(this, void 0, void 0, function () {
        var extended, a, A;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!__hasNativeSupport)
                        return [2 /*return*/, deriveEd25519PublicKey_sync(privateKey)];
                    return [4 /*yield*/, (0, sha2_512_1.sha2_512)(privateKey)];
                case 1:
                    extended = _a.sent();
                    a = scalarFromBytes(extended);
                    A = scalarMul(BASE, a);
                    return [2 /*return*/, bigpointToByteArray(A)];
            }
        });
    });
}
exports.deriveEd25519PublicKey = __hasNativeSupport ? deriveEd25519PublicKey_async : wrapped_deriveEd25519PublicKey_sync;
function extendedToPublic(extended) {
    extended = forceUint8Array(extended);
    var a = scalarFromBytes(extended);
    var A = scalarMul(BASE, a);
    return new Uint8Array(bigpointToByteArray(A));
}
exports.extendedToPublic = extendedToPublic;
/** sign a message with a (32 bytes) private key */
function signEd25519_sync(message, privateKey) {
    message = forceUint8Array(message);
    privateKey = forceUint8Array(privateKey);
    var extendedKey = privateKey.length === 64 ?
        privateKey :
        (0, sha2_512_1.sha2_512_sync)(privateKey);
    return signExtendedEd25519_sync(message, extendedKey);
}
exports.signEd25519_sync = signEd25519_sync;
/** sign a message with a (32 bytes) private key */
function signEd25519(message, privateKey) {
    return __awaiter(this, void 0, void 0, function () {
        var extended, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    privateKey = forceUint8Array(privateKey);
                    if (!(privateKey.length === 64)) return [3 /*break*/, 1];
                    _a = privateKey;
                    return [3 /*break*/, 3];
                case 1: return [4 /*yield*/, (0, sha2_512_1.sha2_512)(privateKey)];
                case 2:
                    _a = _b.sent();
                    _b.label = 3;
                case 3:
                    extended = _a;
                    return [4 /*yield*/, (0, exports.signExtendedEd25519)(message, extended)];
                case 4: return [2 /*return*/, _b.sent()];
            }
        });
    });
}
exports.signEd25519 = signEd25519;
/** sign a message with a (64 bytes) private key */
function signExtendedEd25519_sync(_message, _extendedKey) {
    var _a;
    var message = forceUint8Array(_message);
    var privateKeyHash = forceUint8Array(_extendedKey);
    if (privateKeyHash.length !== 64)
        throw new Error('signExtendedEd25519_sync:: extended key must have length 64');
    var a = scalarFromBytes(privateKeyHash);
    // for convenience getulate publicKey here:
    var publicKey = bigpointToByteArray(scalarMul(BASE, a));
    var r = ihash((0, uint8array_utils_1.concatUint8Array)(privateKeyHash.slice(32, 64), forceUint8Array(message)));
    var R = scalarMul(BASE, r);
    var S = (0, positiveMod_1.positiveMod)(r +
        ihash((0, uint8array_utils_1.concatUint8Array)(bigpointToByteArray(R), publicKey, forceUint8Array(message))) * a, CURVE_ORDER);
    var pubKey = publicKey;
    var signature = (0, uint8array_utils_1.concatUint8Array)(bigpointToByteArray(R), encodeInt(S));
    return _a = {
            0: pubKey,
            1: signature,
            length: 2
        },
        _a[Symbol.iterator] = function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, pubKey];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, signature];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        },
        _a.pubKey = pubKey,
        _a.signature = signature,
        _a;
}
exports.signExtendedEd25519_sync = signExtendedEd25519_sync;
function wrapped_signExtendedEd25519_sync(message, extendedKey) {
    return Promise.resolve(signExtendedEd25519_sync(message, extendedKey));
}
/** sign a message with a (64 bytes) private key */
function nativeExtendedSignEd25519(_message, _extendedKey) {
    return __awaiter(this, void 0, void 0, function () {
        var message, privateKeyHash, a, pubKey, signature;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, ensureNativeSupport()];
                case 1:
                    if (!(_b.sent()))
                        return [2 /*return*/, signExtendedEd25519_sync(_message, _extendedKey)];
                    message = forceUint8Array(_message);
                    privateKeyHash = forceUint8Array(_extendedKey);
                    if (privateKeyHash.length !== 64)
                        throw new Error('nativeExtendedSignEd25519:: extended key must have length 64');
                    a = scalarFromBytes(privateKeyHash);
                    pubKey = bigpointToByteArray(scalarMul(BASE, a));
                    return [4 /*yield*/, nativeEd25519Sign(privateKeyHash, message)];
                case 2:
                    signature = _b.sent();
                    return [2 /*return*/, (_a = {
                                0: pubKey,
                                1: signature,
                                length: 2
                            },
                            _a[Symbol.iterator] = function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, pubKey];
                                        case 1:
                                            _a.sent();
                                            return [4 /*yield*/, signature];
                                        case 2:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            },
                            _a.pubKey = pubKey,
                            _a.signature = signature,
                            _a)];
            }
        });
    });
}
/** sign a message with a (64 bytes) private key */
exports.signExtendedEd25519 = __hasNativeSupport ? nativeExtendedSignEd25519 : wrapped_signExtendedEd25519_sync;
/** sign a message with a (32 bytes) private key */
function getEd25519Signature_sync(message, privateKey) {
    return signEd25519_sync(message, privateKey).signature;
}
exports.getEd25519Signature_sync = getEd25519Signature_sync;
function wrapped_getEd25519Signature_sync(message, privateKey) {
    return Promise.resolve(getEd25519Signature_sync(message, privateKey));
}
/** sign a message with a (32 bytes) private key */
exports.getEd25519Signature = __hasNativeSupport ? nativeEd25519Sign : wrapped_getEd25519Signature_sync;
///////////////////////////////////////////////////////////////////////////////////////////////////// 
//-------------------------------------------------------------------------------------------------// 
//------------------------------------------- verifying -------------------------------------------// 
//-------------------------------------------------------------------------------------------------// 
/////////////////////////////////////////////////////////////////////////////////////////////////////
function verifyEd25519Signature_sync(_signature, _message, _publicKey) {
    var signature = forceUint8Array(_signature);
    var message = forceUint8Array(_message);
    var publicKey = forceUint8Array(_publicKey);
    if (signature.length !== 64 || publicKey.length !== 32) {
        throw new Error("unexpected signature length ".concat(signature.length));
    }
    var R_bytes = forceUint8Array(signature).slice(0, 32);
    var R = pointFromBytes(R_bytes);
    var A = pointFromBytes(forceUint8Array(publicKey));
    var S = decodeInt(forceUint8Array(signature).slice(32, 64));
    var h = ihash((0, uint8array_utils_1.concatUint8Array)(R_bytes, publicKey, message));
    var left = scalarMul(BASE, S);
    var right = addPointsEdwards(R, scalarMul(A, h));
    return (left[0] == right[0]) && (left[1] == right[1]);
}
exports.verifyEd25519Signature_sync = verifyEd25519Signature_sync;
function wrapped_verifyEd25519Signature_sync(signature, message, publicKey) {
    return Promise.resolve(verifyEd25519Signature_sync(signature, message, publicKey));
}
exports.verifyEd25519Signature = __hasNativeSupport ? nativeEd25519Verify : wrapped_verifyEd25519Signature_sync;

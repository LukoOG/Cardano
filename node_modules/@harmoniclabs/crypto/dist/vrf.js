"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VrfBatchVerifier = exports.VrfBatchProof10 = exports.VrfProof10 = exports.derive_vrf10_public_key = exports.VrfProof03 = void 0;
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var curves_1 = require("./rust_vrf_reimpl/curves.js");
var vrf03_1 = require("./rust_vrf_reimpl/vrf03.js");
var vrf10_1 = require("./rust_vrf_reimpl/vrf10.js");
var vrf10_batch_1 = require("./rust_vrf_reimpl/vrf10_batch.js");
var getRandomValues_1 = require("./utils/getRandomValues.js");
var VrfProof03 = /** @class */ (function () {
    function VrfProof03(_a) {
        var gamma = _a.gamma, challenge = _a.challenge, response = _a.response;
        this.gamma = gamma;
        this.challenge = challenge;
        this.response = response;
    }
    VrfProof03.prototype.toHash = function () {
        return (0, vrf03_1.proof_to_hash)(this);
    };
    VrfProof03.generate = function (secret_key, public_key, alpha_string) {
        return new VrfProof03((0, vrf03_1.vrf_ed25519_sha512_ell2_generate_proof)(secret_key, public_key, alpha_string));
    };
    VrfProof03.verify = function (public_key, alpha_string, proof) {
        return (0, vrf03_1.vrf_ed25519_sha512_ell2_verify_proof)(public_key, alpha_string, proof);
    };
    VrfProof03.prototype.verify = function (public_key, alpha_string) {
        return (0, vrf03_1.vrf_ed25519_sha512_ell2_verify_proof)(public_key, alpha_string, this);
    };
    /*
    pub fn to_bytes(&self) -> [u8; PROOF_SIZE] {
        let mut proof = [0u8; PROOF_SIZE];
        proof[..32].copy_from_slice(self.gamma.compress().as_bytes());
        proof[32..48].copy_from_slice(&self.challenge.to_bytes()[..16]);
        proof[48..].copy_from_slice(self.response.as_bytes());

        proof
    }
    */
    VrfProof03.prototype.toBytes = function () {
        var output = new Uint8Array(80);
        output.set(this.gamma.compress(), 0);
        output.set(this.challenge.slice(0, 16), 32);
        output.set(this.response, 48);
        return output;
    };
    VrfProof03.fromBytes = function (bytes) {
        var gamma = curves_1.EdwardsPoint.decompress(Uint8Array.prototype.slice.call(bytes, 0, 32));
        if (!gamma)
            throw new Error("Invalid gamma point");
        var challenge = new Uint8Array(32);
        challenge.set(Uint8Array.prototype.slice.call(bytes, 32, 48), 0);
        var response = Uint8Array.prototype.slice.call(bytes, 48, 80);
        return new VrfProof03({
            gamma: gamma,
            challenge: challenge,
            response: response
        });
    };
    return VrfProof03;
}());
exports.VrfProof03 = VrfProof03;
function derive_vrf10_public_key(secret_key) {
    return curves_1.EdwardsPoint.BASEPOINT_ED25519.scalarMul((0, vrf10_1.extend_secret_key)(secret_key)[0]).compress();
}
exports.derive_vrf10_public_key = derive_vrf10_public_key;
var VrfProof10 = /** @class */ (function () {
    function VrfProof10(_a) {
        var gamma = _a.gamma, challenge = _a.challenge, response = _a.response;
        this.gamma = gamma;
        this.challenge = challenge;
        this.response = response;
    }
    VrfProof10.prototype.toHash = function () {
        return (0, vrf10_1.vrf10_proof_to_hash)(this);
    };
    VrfProof10.generate = function (secret_key, public_key, alpha_string) {
        return new VrfProof10((0, vrf10_1.vrf10_ed25519_sha512_ell2_generate_proof)(secret_key, public_key, alpha_string));
    };
    VrfProof10.verify = function (public_key, alpha_string, proof) {
        return (0, vrf10_1.vrf10_ed25519_sha512_ell2_verify_proof)(public_key, alpha_string, proof);
    };
    VrfProof10.prototype.verify = function (public_key, alpha_string) {
        return (0, vrf10_1.vrf10_ed25519_sha512_ell2_verify_proof)(public_key, alpha_string, this);
    };
    /*
    pub fn to_bytes(&self) -> [u8; PROOF_SIZE] {
        let mut proof = [0u8; PROOF_SIZE];
        proof[..32].copy_from_slice(self.gamma.compress().as_bytes());
        proof[32..48].copy_from_slice(&self.challenge.to_bytes()[..16]);
        proof[48..].copy_from_slice(self.response.as_bytes());

        proof
    }
    */
    VrfProof10.prototype.toBytes = function () {
        var output = new Uint8Array(80);
        output.set(this.gamma.compress(), 0);
        output.set(this.challenge.slice(0, 16), 32);
        output.set(this.response, 48);
        return output;
    };
    VrfProof10.fromBytes = function (bytes) {
        var gamma = curves_1.EdwardsPoint.decompress(Uint8Array.prototype.slice.call(bytes, 0, 32));
        if (!gamma)
            throw new Error("Invalid gamma point");
        var challenge = new Uint8Array(32);
        challenge.set(Uint8Array.prototype.slice.call(bytes, 32, 48), 0);
        var response = Uint8Array.prototype.slice.call(bytes, 48, 80);
        return new VrfProof10({
            gamma: gamma,
            challenge: challenge,
            response: response
        });
    };
    return VrfProof10;
}());
exports.VrfProof10 = VrfProof10;
var VrfBatchProof10 = /** @class */ (function () {
    function VrfBatchProof10(_a) {
        var gamma = _a.gamma, u_point = _a.u_point, v_point = _a.v_point, response = _a.response;
        this.gamma = gamma;
        this.u_point = u_point;
        this.v_point = v_point;
        this.response = response;
    }
    VrfBatchProof10.prototype.toHash = function () {
        return (0, vrf10_batch_1.vrf10_batch_ed25519_sha512_ell2_proof_to_hash)(this);
    };
    VrfBatchProof10.generate = function (secret_key, public_key, alpha_string) {
        return new VrfBatchProof10((0, vrf10_batch_1.vrf10_batch_ed25519_sha512_ell2_generate_proof)(secret_key, public_key, alpha_string));
    };
    VrfBatchProof10.verify = function (public_key, alpha_string, proof) {
        return (0, vrf10_batch_1.vrf10_batch_ed25519_sha512_ell2_verify_proof)(public_key, alpha_string, proof);
    };
    VrfBatchProof10.prototype.verify = function (public_key, alpha_string) {
        return (0, vrf10_batch_1.vrf10_batch_ed25519_sha512_ell2_verify_proof)(public_key, alpha_string, this);
    };
    /*
    pub fn to_bytes(&self) -> [u8; PROOF_SIZE] {
        let mut proof = [0u8; PROOF_SIZE];
        proof[..32].copy_from_slice(self.gamma.compress().as_bytes());
        proof[32..48].copy_from_slice(&self.challenge.to_bytes()[..16]);
        proof[48..].copy_from_slice(self.response.as_bytes());

        proof
    }
    */
    VrfBatchProof10.prototype.toBytes = function () {
        var output = new Uint8Array(128);
        output.set(this.gamma.compress(), 0);
        output.set(this.u_point.compress(), 32);
        output.set(this.v_point.compress(), 64);
        output.set(this.response, 96);
        return output;
    };
    VrfBatchProof10.fromBytes = function (bytes) {
        var gamma = curves_1.EdwardsPoint.decompress(Uint8Array.prototype.slice.call(bytes, 0, 32));
        if (!gamma)
            throw new Error("Invalid gamma point");
        var u_point = curves_1.EdwardsPoint.decompress(Uint8Array.prototype.slice.call(bytes, 32, 64));
        if (!u_point)
            throw new Error("Invalid u_point point");
        var v_point = curves_1.EdwardsPoint.decompress(Uint8Array.prototype.slice.call(bytes, 64, 96));
        if (!v_point)
            throw new Error("Invalid v_point point");
        var response = Uint8Array.prototype.slice.call(bytes, 96, 128);
        return new VrfBatchProof10({
            gamma: gamma,
            u_point: u_point,
            v_point: v_point,
            response: response
        });
    };
    return VrfBatchProof10;
}());
exports.VrfBatchProof10 = VrfBatchProof10;
function gen_u128_bytes() {
    var buff = new Uint8Array(16);
    (0, getRandomValues_1.getRandomValues)(buff);
    return buff;
}
function gen_u128() {
    return BigInt("0x" +
        (0, uint8array_utils_1.toHex)(gen_u128_bytes()));
}
/** for some reason, from 38 elems up it fails */
var MAX_BATCH_SIZE = 37;
var VrfBatchVerifier = /** @class */ (function () {
    function VrfBatchVerifier(size) {
        this.size = size;
        this._currLen = 0;
        this.proof_scalars = new Array(size);
        this.pks = new Array(size);
        this.us = new Array(size);
        this.hs = new Array(size);
        this.gammas = new Array(size);
        this.vs = new Array(size);
        this._currLen = 0;
    }
    VrfBatchVerifier.prototype.insert = function (item) {
        if (this._currLen >= this.size)
            throw new Error("BatchVerifier is full");
        var output = item.proof.toHash();
        var decompressed_pk = curves_1.EdwardsPoint.decompress(item.public_key);
        if (!decompressed_pk || decompressed_pk.is_small_order())
            throw new Error("Invalid public key");
        var h = (0, vrf10_1.vrf10_ed25519_sha512_ell2_hash_to_curve)(item.public_key, item.alpha);
        var compressed_h = h.compress();
        var gamma = item.proof.gamma;
        var compressed_gamma = gamma.compress();
        var u = item.proof.u_point;
        var compressed_u = u.compress();
        var v = item.proof.v_point;
        var compressed_v = v.compress();
        this.proof_scalars[this._currLen] = [
            (0, vrf10_1.vrf10_ed25519_sha512_ell2_compute_challenge)(compressed_h, compressed_gamma, compressed_u, compressed_v),
            item.proof.response
        ];
        this.pks[this._currLen] = decompressed_pk;
        this.us[this._currLen] = u;
        this.hs[this._currLen] = h;
        this.gammas[this._currLen] = gamma;
        this.vs[this._currLen] = v;
        this._currLen++;
    };
    VrfBatchVerifier.prototype.verify = function () {
        var size = this._currLen;
        var b_coeff = scalar_zero();
        /** array of scalars */
        var lchalls = new Array(size);
        /** array of scalars */
        var rchalls = new Array(size);
        /** array of scalars */
        var ls = new Array(size);
        /** array of scalars */
        var rs = new Array(size);
        /** array of scalars */
        var rresponses = new Array(size);
        for (var i = 0; i < size; i++) {
            var _a = __read(this.proof_scalars[i], 2), challenge = _a[0], response = _a[1];
            var li = new Uint8Array(32);
            li.set(gen_u128_bytes(), 0);
            var ri = new Uint8Array(32);
            ri.set(gen_u128_bytes(), 0);
            b_coeff = (0, curves_1.add_scalars)(b_coeff, (0, curves_1.mul_scalars)(li, response));
            lchalls[i] = (0, curves_1.mul_scalars)(li, challenge);
            ls[i] = li;
            rresponses[i] = (0, curves_1.mul_scalars)(ri, (0, curves_1.negate_scalar)(response));
            rchalls[i] = (0, curves_1.mul_scalars)(ri, challenge);
            rs[i] = ri;
        }
        var result = curves_1.EdwardsPoint.vartime_multiscalar_mul([(0, curves_1.negate_scalar)(b_coeff)]
            .concat(lchalls)
            .concat(ls)
            .concat(rresponses)
            .concat(rchalls)
            .concat(rs), [curves_1.EdwardsPoint.BASEPOINT_ED25519]
            .concat(this.pks)
            .concat(this.us)
            .concat(this.hs)
            .concat(this.gammas)
            .concat(this.vs));
        return result.is_identity();
    };
    return VrfBatchVerifier;
}());
exports.VrfBatchVerifier = VrfBatchVerifier;
function scalar_zero() {
    return new Uint8Array(32);
}
